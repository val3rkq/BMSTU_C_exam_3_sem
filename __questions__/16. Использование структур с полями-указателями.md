
```c
struct book_t
{
	char *title;
	int year;
};
```

В Си определена операция присваивания для структурных переменных одного типа. Эта операция фактически эквивалента копированию области памяти, занимаемой одной переменной, в область памяти, которую занимает другая.

#### **Поверхностное копирование**

При этом реализуется стратегия так называемого «поверхностного копирования» (англ., shallow coping), при котором копируется содержимое структурной переменной, но не копируется то, на что могут ссылать поля структуры.

Иногда стратегия «поверхностного копирования» может приводить к ошибкам.

```c
struct book_t a = { 0 }, b = { 0 };

a.title = strdup("Book a");
a.year = 2000;

b.title = strdup("Book b");
b.year = 2005;

a = b;

free(a.title); 
free(b.title); // двойное освобождение
```

До присваивания:
![[Pasted image 20250102165935.png]]

После присваивания:
![[Pasted image 20250102170008.png]]

#### **Глубокое копирование**

Стратегия так называемого «глубокого копирования» (англ., deep coping) подразумевает создание копий объектов, на которые ссылаются поля структуры.

```c
int book_copy(struct book_t *dst, const struct book_t *src)
{
	char *ptmp = strdup(src->title);
	if (ptmp)
	{
		free(dst->title);
		dst->title = ptmp;
		dst->year = src->year;
		
		return 0;
	}
	
	return 1;
}

...

book_copy(&b, &a); // вместо b = a

free(a.title);
free(b.title);
```


До копирования:
![[Pasted image 20250102165935.png]]

После копирования:
![[Pasted image 20250102170553.png]]

#### **Рекурсивное освобождение памяти**

Для выделенной динамически структура с полем-указателем. При освобождении памяти — сначала надо освободить память из-под внутренних полей, потом из-под самой структуры.

```c
free(book.title);
free(book);
```