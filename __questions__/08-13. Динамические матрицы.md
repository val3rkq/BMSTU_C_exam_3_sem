- Динамические матрицы. Представление в виде одномерного массива и в виде массива указателей на строки. Анализ преимуществ и недостатков.
- Динамические матрицы. Представление в виде одномерного массива и в виде массива указателей на строки матрицы (1 подход). Анализ преимуществ и недостатков.
- Динамические матрицы. Представление в виде одномерного массива и в виде массива указателей на строки матрицы (2 подход). Анализ преимуществ и недостатков.
- Динамические матрицы. Представление в виде массива указателей на строки матрицы и в виде массива указателей на строки матрицы (1 подход). Анализ преимуществ и недостатков.
- Динамические матрицы. Представление в виде массива указателей на строки матрицы и в виде массива указателей на строки матрицы (2 подход). Анализ преимуществ и недостатков.
---

#### **Матрица как одномерный массив**

![](<../__res__/Pasted image 20250101214810.png>)

Выделение памяти

```c
double *data = malloc(n * m * sizeof(double));
```

Очищение памяти

```c
free(data);
```

|                             +                              |                                      -                                       |
| :--------------------------------------------------------: | :--------------------------------------------------------------------------: |
|    <br>простота выделения и освобождения памяти<br><br>    | <br>отладчик использования памяти не может отследить выход за пределы строки |
| <br>возможность использовать как одномерный массив<br><br> |                         <br>нужно писать `i * m + j`                         |

#### **Матрица как массив указателей на строки**

![](<../__res__/Pasted image 20250101220252.png>)

Выделение памяти

```c
double **allocate_matrix(size_t n, size_t m)
{
	double **data = calloc(n, sizeof(double *));
	if (!data)
		return NULL;
	for (size_t i = 0; i < n; i++)
	{
		data[i] = malloc(m * sizeof(double));
		if (!data[i])
		{
			free_matrix(data);
			return NULL;
		}
	}
	return data;
}
```

Очищение памяти

```c
void free_matrix(double **data, size_t n)
{
	for (size_t i = 0; i < n; i++)
		free(data[i]); // free можно передать NULL
		
	free(data);
}
```

|                                         +                                         |                           -                           |
| :-------------------------------------------------------------------------------: | :---------------------------------------------------: |
|           <br>возможность обмена строки через обмен указателей<br><br>            | <br>сложность выделения и освобождения памяти<br><br> |
| <br>отладчик использования памяти может отследить выход за пределы строки<br><br> |   <br>память под матрицу "не лежит" одной областью    |

#### **Объединенный подход (1)**

![](<../__res__/Pasted image 20250101220343.png>)

Выделение памяти

```c
double **allocate_matrix(size_t n, size_t m)
{
	double **ptrs, *data;
	ptrs = malloc(n * sizeof(double *));
	if (!ptrs)
		return NULL;
	data = malloc(n * m * sizeof(double));
	if (!data)
	{
		free(ptrs);
		return NULL;
	}
	for (size_t i = 0; i < n; i++)
		ptrs[i] = data + i * m;
	return ptrs;
}
```

Очищение памяти

```c
void free_matrix(double **data, size_t n)
{
	free(data[0]); // скрывается потенциальная ошибка
	free(data); 
}

void free_matrix(double **data, size_t n)
{
	if (data)
	{
		double *prow = data[0];
		for (size_t i = 1; i < n; i++)
			if (data[i] < prow)
				prow = data[i];
		free(prow);
		free(data);
	}
}
```

|                                 +                                  |                                      -                                       |
| :----------------------------------------------------------------: | :--------------------------------------------------------------------------: |
| <br>относительная простота выделения и освобождения памяти<br><br> | <br>отладчик использования памяти не может отследить выход за пределы строки |
|     <br>возможность использовать как одномерный массив<br><br>     |           <br>относительная сложность начальной инициализации<br>            |
|       <br>перестановка строк через обмен указателей<br><br>        |                                                                              |

#### **Объединенный подход (2)**

![](<../__res__/Pasted image 20250101222205.png>)

Выделение памяти

```c
double **allocate_matrix(size_t n, size_t m)
{
	double **data = malloc(n * sizeof(double *) + n * m * sizeof(double));
	if (!data)
		return NULL;
	for (size_t i = 0; i < n; i++)
		data[i] = (double *) ((char *) data + n * sizeof(double *) + i * m * sizeof(double));
	return data;
}
```

Очищение памяти

```c
free(data);
```

|                             +                              |                                      -                                       |
| :--------------------------------------------------------: | :--------------------------------------------------------------------------: |
|   <br>перестановка строк через обмен указателей<br><br>    | <br>отладчик использования памяти не может отследить выход за пределы строки |
| <br>возможность использовать как одномерный массив<br><br> |                  <br>сложность начальной инициализации<br>                   |
|    <br>простота выделения и освобождения памяти<br><br>    |                                                                              |

#### **Сравнительная таблица**

|                                  -                                   | одномерный массив | массив указателей |   объединение (1)   | объединение (2) |
| :------------------------------------------------------------------: | :---------------: | :---------------: | :-----------------: | :-------------: |
|            возможность использовать как одномерный массив            |       есть        |        нет        |        есть         |      есть       |
|                   выделение и освобождение памяти                    |      просто       |      сложно       | относительно просто |     просто      |
|                       начальная инициализация                        |         -         |         -         | относительно сложно |     сложно      |
| отладчик использования памяти может отследить выход за пределы строк |        нет        |        да         |         нет         |       нет       |
|              перестановка строк через обмен указателей               |         -         |        да         |       да [?]        |       да        |

#### **Передача динамической матрицы в функцию. Примеры**

```c
void print_mtx(double **mtx);

...
double **mtx = alloc_mtx(N, M);
print_mtx(mtx);
```

#### **Функция, которая может обрабатывать как статические, так и динамические матрицы.**

```c
void print_matrix(double *mtx, size_t n, size_t m)
{
	for (size_t i = 0; i < n; i++)
		for (size_t j = 0; j < m; j++)
			printf("%lf ", mtx[j + i * m]);
}

...
// статическая матрица
print_matrix((double *) a, N, M);

// динамическая матрица
print_matrix((double *) (b + N), N, M);
```
