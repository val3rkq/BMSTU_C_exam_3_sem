
- Куча в программе на си. Алгоритм работы функции *malloc*. Пример реализации
- Куча в программе на си. Алгоритм работы функции *free*. Пример реализации
- Куча в программе на си. Проблемы выравнивания выделенной области памяти.

---
Области, в которых программа может размещать данные 
1. сегменты данных - константы и глобальные переменные
2. стек - для вызова функций и создания локальных переменных
3. куча - для динамического выделения памяти

#### **Общее**

**Куча** – пул доступной памяти. В куче нет определенного порядка в расположении элементов.

**Происхождение термина куча**. Вероятно, как противопоставление термину **стека**, т.к. в стеке элементы расположены строго один над другим, а в куче нет определенного порядка в расположении элементов.

- Для хранения данных используется *куча*
- Создать переменную в «куче» нельзя, но можно выделить память под нее. 

**Преимущества и недостатки динамической памяти.**

 `+` 
1. размер данных известен на этапе выполнения программы и не нужен на этапе компиляции
2. размер данных, размещающихся в куче на несколько порядков больше размера данных, размещаемых на стеке
3. время жизни данных в куче никак не связана со временем жизни того блока, в котором выделялась память под эти данные. Т.е. можно выделить память в одной функции, а очистить в другой.
 `-` 
 1. Ручное управление временем жизни (сами выделили память, сами освободили память)

**Свойства области, выделенной malloc:**

- malloc выделяет по крайней мере указанное количество байт (меньше нельзя, больше можно).
- Указатель, возвращенный malloc, указывает на выделенную область (т.е. область, в которую программа может писать и из которой может читать данные).
- Ни один другой вызов malloc не может выделить эту область или ее часть, если только она не была освобождена с помощью free.

###### **Область**

```c
struct block_t
{
	size_t size;
	int free;
	struct block_t *next;
}
```
###### **Инициализация области**

```c
#define MY_HEAP_SIZE 1000000

// пространство под "кучу"
static char my_heap[MY_HEAP_SIZE];

// список свободных / занятых областей
static struct block_t *free_list = (struct block_t *) my_heap;

// начальная инициализация списка свободных / занятых областей
static void initialize(void)
{
	free_list->size = sizeof(my_heap) - sizeof(struct block_t);
	free_list->free = 1;
	free_list->next = NULL;
}
```

#### **Алгоритм работы malloc**

Выделение области памяти (malloc):

- Просмотреть список занятых/свободных областей памяти в поисках свободной области подходящего размера.
- Если область имеет точно такой размер, как запрашивается, пометить найденную область как занятую и вернуть указатель на начало области памяти.
- Если область имеет больший размер, разделить ее на части, одна из которых будет занята (выделена), а другая останется свободной.
- Если область не найдена, вернуть нулевой указатель.

![[Pasted image 20250103184441.png]]

```c
static void split_block(struct block_t *block, size_t size)
{
	// остаток области памяти после выделения
	size_t rest = block->size - size;

	if (rest > sizeof(struct block_t))
	{
		struct block_t *new = (void *) ((char *) block + size + sizeof(struct block_t));

		new->size = block->size - size - sizeof(struct block_t);
		new->free = 1;
		new->next = block->next;

		block->size = size;
		block->free = 0;
		block->next = new;
	}
	else
		block->free = 0;
}

void *my_malloc(size_t size)
{
	struct block_t *cur;
	void *result;

	// все глобальные переменные в Си неявно инициализируются нулями
	if (!free_list->size)
		initialize();

	cur = free_list;	
	while (cur && (cur->free == 0 || cur->size < size))
		cur = cur->next;

	if (!cur)
	{
		result = NULL;
		printf("Out of memory\n");
	}
	else if (cur->size == size)
	{
		cur->free = 0;
		result = (void *) (++cur);
	}
	else 
	{
		split_block(cur, size);
		result = (void *) (++cur);
	}

	return result;
}
```

#### **Алгоритм работы free**

Освобождение области памяти (free):

- Просмотреть список занятых/свободных областей памяти в поисках указанной области.
- Пометить найденную область как свободную. 
- Если освобожденная область вплотную граничит со свободной областью с какой-либо из двух сторон, то объединить их в единую область большего размера.

![[Pasted image 20250107094601.png]]

```c
static void merge_blocks(void)
{
	struct block_t *cur = free_list;

	while (cur && cur->next)
	{
		if (cur->free && cur->next->free)
		{
			cur->size += cur->next->size + sizeof(struct block_t);
			cur->next = cur->next->next;
		}
		else
			cur = cur->next;
	}
}

void my_free(void *ptr)
{
	// проверка не обязательна
	if (my_heap <= (char *) ptr && (char *) ptr < my_heap + sizeof(my_heap))
	{
		struct block_t *cur = ptr;
		--cur;
		cur->free = 1;

		merge_blocks();
	}
	else 
		printf("Wrong pointer\n");
}
```


#### **Дефрагментация**

![[Pasted image 20250103191142.png]]

**Фрагментация** - чередование участков памяти при последовательных запросах на
выделение и освобождение памяти. «Занятые» участки чередуются со
«свободными» - однако последние могут быть недостаточно большими для того,
чтобы сохранить в них нужное данное.

Дефрагментация в куче выполняется для устранения фрагментации и улучшения производительности выделения и освобождения блоков памяти. В процессе дефрагментации происходит перераспределение блоков памяти таким образом, чтобы создать большие непрерывные свободные блоки и уменьшить фрагментацию.
#### **Проблемы выравнивания выделенной области памяти.**

Для хранения произвольных объектов блок должен быть правильно выровнен. В каждой системе есть самый «требовательный» тип данных - если элемент этого типа можно поместить по некоторому адресу, то любые другие элементы тоже можно поместить туда.

```c
// определить самый требовательный тип
typedef long long align_t;

// объединение будет выравнено по правильному адресу - самого требовательного типа
union block_t
{
	// структура будет выравнена по максимальному элементу
	struct
	{
		size_t size;
		int free;
		union block_t *next;
	} block;

	align_t x;
};

// чтобы все были выравнены одинаковыми, размер выделенной памяти кратной размеру метаинформации - размер области в блоках - затем в байтах, но правильно
```

Запрашиваемый размер области обычно округляется до размера кратного размеру заголовка.

```c
n_blocks = (size - 1 + sizeof(union block_t)) / sizeof(union block_t) + 1;
alloc_size = n_blocks * sizeof(union block_t);
```

**Выравнивание** - размещение значений в памяти по адресам, кратным некоторому целому числу, больше единицы.

Причина, по которой существует такое понятие как **выравнивание**, заключается в том, что процессорам проще оперировать выровненными значениями.

Естественное выравнивание *natural alignment* - выравнивание значений встроенных типов (как правило, поддерживаемых процессором непосредственно) по адресам, кратным размеру этого типа. Например, 4-байтные целые размещаются по адресам, кратным четырём (0, 4, 8, 12, ... ), а 8-байтные значения типа double размещаются по адресам, кратным восьми (0, 8, 16, 24, ... ).